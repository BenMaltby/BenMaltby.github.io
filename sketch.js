let clock3Raw = [
  [-27.54, 11, -26.93, 17, -24.39, 23, -20.10, 28, -14.59, 32, -8.34, 34, -1.75, 35, 4.91, 35, 11.41, 34, 17.44, 31, 22.54, 27, 26.23, 21, 28.20, 15, 28.63, 8, 27.46, 2, 24.30, -4, 19.38, -9, 13.35, -11, 19.06, -15, 23.60, -20, 26.53, -26, 27.28, -32, 26.35, -39, 23.78, -45, 19.46, -50, 13.81, -53, 7.44, -55, 0.82, -56, -5.83, -55, -12.19, -53, -17.87, -50, -22.51, -45, -25.61, -39, -26.85, -33, -21.69, -31, -15.59, -32, -14.16, -38, -9.99, -43, -3.93, -46, 2.69, -47, 9.11, -45, 13.91, -40, 15.85, -34, 15.68, -27, 12.88, -21, 7.59, -17, 1.17, -16, -5.50, -16, -9.62, -13, -9.62, -7, -9.27, -7, -2.61, -7, 4.03, -6, 10.29, -4, 15.08, 1, 17.20, 7, 17.07, 14, 14.78, 20, 9.88, 24, 3.52, 26, -3.14, 26, -9.39, 24, -14.12, 19, -16.22, 13, -20.87, 11, -27.54, 11]
]

let clock6Raw = [
  [8.19, -53, 1.70, -52, -4.46, -49, -10.02, -46, -14.75, -41, -18.51, -35, -21.32, -29, -23.29, -23, -24.56, -16, -25.24, -10, -25.45, -3, -25.41, 4, -24.71, 10, -23.03, 17, -20.21, 23, -16.25, 28, -11.17, 32, -5.15, 35, 1.39, 36, 8.05, 36, 14.48, 34, 20.21, 31, 24.82, 26, 28.12, 20, 30.01, 14, 30.69, 7, 30.37, 1, 28.92, -6, 26.10, -12, 21.91, -17, 16.47, -21, 10.12, -23, 3.49, -23, -3.08, -22, -9.13, -19, -13.89, -15, -12.80, -22, -10.63, -28, -7.14, -34, -2.38, -39, 3.42, -42, 9.81, -44, 16.46, -44, 18.19, -49, 16.18, -54, 14.83, -54, 8.19, -53],
  [-3.16, -13, -8.83, -9, -13.02, -4, -14.10, 2, -13.61, 9, -11.83, 15, -8.44, 21, -3.36, 25, 3.08, 27, 9.59, 26, 14.84, 22, 18.08, 16, 19.42, 9, 19.32, 3, 17.72, -4, 14.18, -9, 8.69, -13, 3.35, -14, -3.16, -13]
]

let clock9Raw = [
  [-14.89, 26, -14.89, 33, -10.32, 35, -3.71, 34, 2.78, 33, 8.93, 30, 14.47, 27, 19.11, 22, 22.66, 16, 25.18, 10, 26.85, 4, 27.88, -3, 28.39, -10, 28.51, -16, 28.35, -23, 27.53, -30, 25.81, -36, 23.01, -42, 19.02, -47, 13.83, -52, 7.71, -54, 1.12, -55, -5.53, -55, -11.88, -53, -17.49, -49, -21.90, -44, -24.96, -38, -26.75, -32, -27.40, -25, -27.00, -18, -25.44, -12, -22.63, -6, -18.44, -1, -12.97, 3, -6.63, 5, 0.00, 5, 6.48, 4, 12.29, 1, 17.15, -4, 16.84, 0, 15.61, 7, 13.18, 13, 9.21, 18, 3.82, 22, -2.41, 24, -8.98, 25, -14.89, 26],
  [16.12, -14, 17.21, -20, 16.77, -27, 15.14, -33, 11.97, -39, 7.14, -44, 0.80, -46, -5.72, -45, -11.11, -41, -14.56, -35, -16.10, -29, -16.17, -22, -14.83, -15, -11.69, -10, -6.60, -5, -0.24, -4, 6.27, -5, 11.88, -9, 16.12, -14]
]

let clock12Raw = [
  [0.36, 34, 7.04, 34, 11.07, 32, 11.07, 25, 11.07, 18, 11.07, 12, 11.07, 5, 11.07, -2, 11.07, -8, 11.07, -15, 11.07, -22, 11.07, -28, 11.07, -35, 11.07, -42, 11.07, -48, 11.07, -55, 11.02, -55, 4.65, -53, -1.58, -51, -7.82, -49, -14.07, -46, -20.31, -44, -23.04, -39, -22.90, -33, -16.64, -35, -10.38, -37, -4.13, -40, -0.28, -38, -0.28, -32, -0.28, -25, -0.28, -18, -0.28, -12, -0.28, -5, -0.28, 2, -0.28, 8, -0.28, 15, -0.28, 22, -0.28, 28, 0.36, 34],
  
  [44.93, 34, 51.59, 34, 58.27, 34, 64.93, 34, 71.61, 34, 78.26, 34, 84.93, 34, 91.60, 34, 98.26, 34, 102.38, 32, 102.38, 25, 101.45, 25, 94.78, 25, 88.11, 25, 81.45, 25, 74.78, 25, 68.11, 25, 61.44, 25, 59.80, 23, 64.32, 18, 68.83, 13, 73.34, 8, 77.86, 3, 82.38, -2, 86.72, -7, 90.70, -12, 94.17, -18, 96.84, -24, 98.23, -30, 97.87, -37, 95.77, -43, 91.82, -49, 86.46, -53, 80.22, -55, 73.64, -56, 66.97, -56, 60.47, -54, 54.42, -51, 49.31, -47, 45.46, -42, 43.19, -36, 42.45, -29, 48.62, -28, 53.78, -30, 55.07, -37, 58.68, -42, 64.32, -46, 70.88, -47, 77.44, -46, 82.91, -42, 86.18, -36, 86.91, -30, 85.47, -23, 82.27, -17, 78.24, -12, 73.88, -7, 69.42, -2, 64.96, 3, 60.50, 8, 56.05, 13, 51.58, 18, 47.12, 23, 44.15, 28, 44.93, 34]
]

class ball{
  constructor(){
    this.pos = createVector(mouseX, mouseY)
    this.rad = 30
    this.vel = createVector()
    this.prevPos = createVector()
  }
  
  collision(groups, xOff, yOff){
    for (let points of groups){
      for (let i = 0; i < points.length; i++){
        let c = points[i].pos
        let vBet = p5.Vector.sub(c, p5.Vector.sub(this.pos, createVector(width/2+xOff, height/2+yOff)))
        let m = p5.Vector.mag(vBet)
        if (m < this.rad + strokeRad/2){
          c.add(p5.Vector.sub(p5.Vector.setMag(vBet, this.rad + strokeRad/2), vBet))
          points[i].vel = p5.Vector.mult(this.vel, 1.2)
        }
      }
    }
  }
  
  process(){
    
    this.pos = createVector(mouseX, mouseY)
    this.vel = p5.Vector.sub(this.pos, this.prevPos)
    
    // strokeWeight(2)
    // noFill()
    // circle(this.pos.x - width/2, this.pos.y - height/2, this.rad*2)
    
    // this.collision(points, xOff, yOff)
    
    this.prevPos = this.pos.copy()
  }
}

class smartPoint{
  constructor(pos){
    this.pos = pos.copy()
    this.target = pos.copy()
    this.rad = strokeRad
    this.vel = createVector(0, 0)
    this.desiredVel = createVector(0, 0)
    this.steering = 0.1
    this.speedLimit = 50
    this.easingValue = -0.55 // between -1 and -0.46
  }
  
  static process(groups, xOff, yOff, b){    
    let slowThreshold = 5;
    
    for (let ps of groups){
      for (let p = 0; p < ps.length; p++){
        let c = ps[p]

        c.desiredVel = p5.Vector.limit(p5.Vector.sub(c.target, c.pos), c.speedLimit)
        c.vel.limit(c.speedLimit)
        let left = p5.Vector.mult(c.vel, 1-c.steering)
        let right = p5.Vector.mult(c.desiredVel, c.steering)
        let steer = p5.Vector.add(left, right)
        c.vel = p5.Vector.limit(p5.Vector.add(c.vel, steer), this.speedlimit)

        // slow the bitch down
        let distB = p5.Vector.mag(p5.Vector.sub(c.target, c.pos))
        c.vel.add(p5.Vector.mult(c.vel, c.easingValue))

        c.pos.add(c.vel)
        
        
        // handle collision
        let vBet = p5.Vector.sub(c.pos, p5.Vector.sub(b.pos, createVector(width/2+xOff, height/2+yOff)))
        let m = p5.Vector.mag(vBet)
        if (m < b.rad + strokeRad/2){
          c.pos.add(p5.Vector.sub(p5.Vector.setMag(vBet, b.rad + strokeRad/2), vBet))
          c.vel = p5.Vector.mult(b.vel, 1.2)
        }
        
        
        // display Point
        strokeWeight(strokeRad)
        point(c.pos.x + xOff, c.pos.y + yOff)
      }
    }
  }
}

let clockRadius = 0;
let hourRadius = 0;
let minuteRadius = 0;
let secondRadius = 0;
let strokeRad = 5;

let font;
let clockFontSize = 125;
let clock3Groups;
let clock6Groups;
let clock9Groups;
let clock12Groups;
let clockN = 140

let globalPoints = []

let wreckingBall;

function preload() {
  font = loadFont("Roboto-Regular.ttf");
}

function setup() { 
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB)
  rectMode(CENTER);
  
  clockRadius = width/2 - strokeRad
  secondRadius = clockRadius - strokeRad
  hourRadius = clockRadius * 0.9
  minuteRadius = clockRadius * 0.6
  
  wreckingBall = new ball()
  
  clock3Groups = generateDotPath(clock3Raw, clockN);
  clock6Groups = generateDotPath(clock6Raw, clockN);
  clock9Groups = generateDotPath(clock9Raw, clockN);
  clock12Groups = generateDotPath(clock12Raw, clockN);
  
  globalPoints = [
    {groups: clock3Groups, xOff: 310, yOff: 10},
    {groups: clock6Groups, xOff: 0, yOff: 310},
    {groups: clock9Groups, xOff: -310, yOff: 10},
    {groups: clock12Groups, xOff: -40, yOff: -280},
  ]
  
  // vectorToPoints(font.textToPoints('9', ps[2], ps[3], clockFontSize, { sampleFactor:  0.15 }))
  // noLoop()
} 

function vectorToPoints(ps){
  let s = ""
    for (let p of ps){
      let temp = `${p.x.toFixed(2)}, ${p.y.toFixed()}, `
      s = s.concat(temp)
      // formatted.push(p.x - width/2)
      // formatted.push(p.y - width/2)
    }
    console.log(s)
}

function draw() { 
  background(90);
  translate(width/2, height/2)
  
  // Draw the numbers of the clock
  // strokeWeight(strokeRad)
  // drawDotGroups(310, 10, clock3Groups, type="LINES")
  // drawDotGroups(0, 310, clock6Groups, type="LINES")
  // drawDotGroups(-310, 10, clock9Groups, type="LINES")
  // drawDotGroups(-40, -280, clock12Groups, type="POINTS")
  
  // let hourAngle = (hour() / 12) * TAU - PI/2
  // let minuteAngle = (minute() / 60) * TAU - PI/2
  // let secondAngle = (second() / 60) * TAU - PI/2
  // strokeWeight(5)
  // stroke(0, 70, 100)
  // line(0, 0, secondRadius * cos(secondAngle), secondRadius * sin(secondAngle))
  // strokeWeight(10)
  // stroke(0, 70, 100)
  // line(0, 0, minuteRadius * cos(minuteAngle), minuteRadius * sin(minuteAngle))
  // stroke(0, 70, 100)
  // line(0, 0, hourRadius * cos(hourAngle), hourRadius * sin(hourAngle))
  stroke(220, 70, 70)
  noFill()
  strokeWeight(strokeRad)
  circle(0, 0, clockRadius * 2) 
  
  if (mouseIsPressed){
    wreckingBall.process()
  }else{
    wreckingBall.pos = createVector(-windowWidth, -windowHeight)
  }
  for (let g of globalPoints){
    smartPoint.process(g.groups, g.xOff, g.yOff, wreckingBall)
  }
  
  
  // strokeWeight(2)
  // stroke(0)
  // line(-width/2, 0, width/2, 0)
  // line(0, -height/2, 0, height/2)
}

function touchStarted(){
  return false;
}

function touchMoved(){
  return false;
}

function touchEnded(){
  return false;
}

function drawShape(x, y, ps){
  push()
  translate(x, y)
  beginShape()
  for (let i = 0; i < ps.length; i++){
    vertex(ps[i].pos.x, ps[i].pos.y)
  }
  endShape()
  pop()
}

function drawDotGroups(x, y, ps, type="POINTS", isSmart=true){
  push()
  translate(x, y)
  if (type == "POINTS"){
    for (let group of ps){
      for (let p of group){
        let c = (isSmart) ? p.pos : p
        point(c.x, c.y)
      }
    }
  }
  else if (type == "LINES"){
    for (let group of ps){
      for (let p = 0; p < group.length-1; p++){
        line(group[p].pos.x, group[p].pos.y, group[p+1].pos.x, group[p+1].pos.y)
      }
    }
  }
  pop()
}

// da best
function generateDotPath(rawShapes, n){
  let vecShape = []
  let spacing = 0;
  let final = []
  let groups = []
  
  for (let rawShape of rawShapes){
    // convert raw points into createVector's
    for (let i = 0; i < rawShape.length; i+=2){
      vecShape.push(createVector(rawShape[i], rawShape[i+1]))
    }
    
    // calculate spacing between points
    let totalLength = 0;
    for (let i = 0; i < vecShape.length-1; i++){
      totalLength += p5.Vector.mag(p5.Vector.sub(vecShape[i+1], vecShape[i]))
    }
    spacing = totalLength / n;

    let percentage = 0
    let currLength = 0;

    for (let i = 0; i < 1; i+=spacing/totalLength){
      percentage = i
      currLength = 0

      for (let i = 0; i < vecShape.length - 1; i++){
        let vBet = p5.Vector.sub(vecShape[i+1], vecShape[i])
        let m = p5.Vector.mag(vBet)
        currLength += m

        if (currLength / totalLength >= percentage){
          let prevLength = currLength - m
          let distance = (percentage * totalLength - prevLength) / (currLength - prevLength)

          let scaled = p5.Vector.setMag(vBet, distance * m)
          let finalPos = p5.Vector.add(vecShape[i], scaled)
          final.push(new smartPoint(finalPos))
          break;
        }

      }
    }
    vecShape = []
    groups.push(final)
    final = []
  }
  
  return groups
}
