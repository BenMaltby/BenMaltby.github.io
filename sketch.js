let clock3Raw = [
  [-55.08, 22.00, -53.86, 34.00, -48.78, 46.00, -40.20, 56.00, -29.18, 64.00, -16.68, 68.00, -3.50, 70.00, 9.82, 70.00, 22.82, 68.00, 34.88, 62.00, 45.08, 54.00, 52.46, 42.00, 56.40, 30.00, 57.26, 16.00, 54.92, 4.00, 48.60, -8.00, 38.76, -18.00, 26.70, -22.00, 38.12, -30.00, 47.20, -40.00, 53.06, -52.00, 54.56, -64.00, 52.70, -78.00, 47.56, -90.00, 38.92, -100.00, 27.62, -106.00, 14.88, -110.00, 1.64, -112.00, -11.66, -110.00, -24.38, -106.00, -35.74, -100.00, -45.02, -90.00, -51.22, -78.00, -53.70, -66.00, -43.38, -62.00, -31.18, -64.00, -28.32, -76.00, -19.98, -86.00, -7.86, -92.00, 5.38, -94.00, 18.22, -90.00, 27.82, -80.00, 31.70, -68.00, 31.36, -54.00, 25.76, -42.00, 15.18, -34.00, 2.34, -32.00, -11.00, -32.00, -19.24, -26.00, -19.24, -14.00, -18.54, -14.00, -5.22, -14.00, 8.06, -12.00, 20.58, -8.00, 30.16, 2.00, 34.40, 14.00, 34.14, 28.00, 29.56, 40.00, 19.76, 48.00, 7.04, 52.00, -6.28, 52.00, -18.78, 48.00, -28.24, 38.00, -32.44, 26.00, -41.74, 22.00, -55.08, 22.00]
]

let clock6Raw = [
  
[16.38, -106.00, 3.40, -104.00, -8.92, -98.00, -20.04, -92.00, -29.50, -82.00, -37.02, -70.00, -42.64, -58.00, -46.58, -46.00, -49.12, -32.00, -50.48, -20.00, -50.90, -6.00, -50.82, 8.00, -49.42, 20.00, -46.06, 34.00, -40.42, 46.00, -32.50, 56.00, -22.34, 64.00, -10.30, 70.00, 2.78, 72.00, 16.10, 72.00, 28.96, 68.00, 40.42, 62.00, 49.64, 52.00, 56.24, 40.00, 60.02, 28.00, 61.38, 14.00, 60.74, 2.00, 57.84, -12.00, 52.20, -24.00, 43.82, -34.00, 32.94, -42.00, 20.24, -46.00, 6.98, -46.00, -6.16, -44.00, -18.26, -38.00, -27.78, -30.00, -25.60, -44.00, -21.26, -56.00, -14.28, -68.00, -4.76, -78.00, 6.84, -84.00, 19.62, -88.00, 32.92, -88.00, 36.38, -98.00, 32.36, -108.00, 29.66, -108.00, 16.38, -106.00], [-6.32, -26.00, -17.66, -18.00, -26.04, -8.00, -28.20, 4.00, -27.22, 18.00, -23.66, 30.00, -16.88, 42.00, -6.72, 50.00, 6.16, 54.00, 19.18, 52.00, 29.68, 44.00, 36.16, 32.00, 38.84, 18.00, 38.64, 6.00, 35.44, -8.00, 28.36, -18.00, 17.38, -26.00, 6.70, -28.00, -6.32, -26.00, ]
]

let clock9Raw = [
  [-29.78, 52.00, -29.78, 66.00, -20.64, 70.00, -7.42, 68.00, 5.56, 66.00, 17.86, 60.00, 28.94, 54.00, 38.22, 44.00, 45.32, 32.00, 50.36, 20.00, 53.70, 8.00, 55.76, -6.00, 56.78, -20.00, 57.02, -32.00, 56.70, -46.00, 55.06, -60.00, 51.62, -72.00, 46.02, -84.00, 38.04, -94.00, 27.66, -104.00, 15.42, -108.00, 2.24, -110.00, -11.06, -110.00, -23.76, -106.00, -34.98, -98.00, -43.80, -88.00, -49.92, -76.00, -53.50, -64.00, -54.80, -50.00, -54.00, -36.00, -50.88, -24.00, -45.26, -12.00, -36.88, -2.00, -25.94, 6.00, -13.26, 10.00, 0.00, 10.00, 12.96, 8.00, 24.58, 2.00, 34.30, -8.00, 33.68, 0.00, 31.22, 14.00, 26.36, 26.00, 18.42, 36.00, 7.64, 44.00, -4.82, 48.00, -17.96, 50.00, -29.78, 52.00 ], [32.24, -28.00, 34.42, -40.00, 33.54, -54.00, 30.28, -66.00, 23.94, -78.00, 14.28, -88.00, 1.60, -92.00, -11.44, -90.00, -22.22, -82.00, -29.12, -70.00, -32.20, -58.00, -32.34, -44.00, -29.66, -30.00, -23.38, -20.00, -13.20, -10.00, -0.48, -8.00, 12.54, -10.00, 23.76, -18.00, 32.24, -28.00, ]
]

let clock12Raw = [
  [0.72, 68.00, 14.08, 68.00, 22.14, 64.00, 22.14, 50.00, 22.14, 36.00, 22.14, 24.00, 22.14, 10.00, 22.14, -4.00, 22.14, -16.00, 22.14, -30.00, 22.14, -44.00, 22.14, -56.00, 22.14, -70.00, 22.14, -84.00, 22.14, -96.00, 22.14, -110.00, 22.04, -110.00, 9.30, -106.00, -3.16, -102.00, -15.64, -98.00, -28.14, -92.00, -40.62, -88.00, -46.08, -78.00, -45.80, -66.00, -33.28, -70.00, -20.76, -74.00, -8.26, -80.00, -0.56, -76.00, -0.56, -64.00, -0.56, -50.00, -0.56, -36.00, -0.56, -24.00, -0.56, -10.00, -0.56, 4.00, -0.56, 16.00, -0.56, 30.00, -0.56, 44.00, -0.56, 56.00, 0.72, 68.00 ], [89.86, 68.00, 103.18, 68.00, 116.54, 68.00, 129.86, 68.00, 143.22, 68.00, 156.52, 68.00, 169.86, 68.00, 183.20, 68.00, 196.52, 68.00, 204.76, 64.00, 204.76, 50.00, 202.90, 50.00, 189.56, 50.00, 176.22, 50.00, 162.90, 50.00, 149.56, 50.00, 136.22, 50.00, 122.88, 50.00, 119.60, 46.00, 128.64, 36.00, 137.66, 26.00, 146.68, 16.00, 155.72, 6.00, 164.76, -4.00, 173.44, -14.00, 181.40, -24.00, 188.34, -36.00, 193.68, -48.00, 196.46, -60.00, 195.74, -74.00, 191.54, -86.00, 183.64, -98.00, 172.92, -106.00, 160.44, -110.00, 147.28, -112.00, 133.94, -112.00, 120.94, -108.00, 108.84, -102.00, 98.62, -94.00, 90.92, -84.00, 86.38, -72.00, 84.90, -58.00, 97.24, -56.00, 107.56, -60.00, 110.14, -74.00, 117.36, -84.00, 128.64, -92.00, 141.76, -94.00, 154.88, -92.00, 165.82, -84.00, 172.36, -72.00, 173.82, -60.00, 170.94, -46.00, 164.54, -34.00, 156.48, -24.00, 147.76, -14.00, 138.84, -4.00, 129.92, 6.00, 121.00, 16.00, 112.10, 26.00, 103.16, 36.00, 94.24, 46.00, 88.30, 56.00, 89.86, 68.00, ]
]

class ball{
  constructor(){
    this.pos = createVector(mouseX, mouseY)
    this.rad = 50
    this.vel = createVector()
    this.prevPos = createVector()
  }
  
  process(){
    
    this.pos = createVector(mouseX, mouseY)
    this.vel = p5.Vector.sub(this.pos, this.prevPos)
    
    // strokeWeight(2)
    // noFill()
    // circle(this.pos.x - width/2, this.pos.y - height/2, this.rad*2)
    
    this.prevPos = this.pos.copy()
  }
}

class smartPoint{
  constructor(pos){
    this.pos = pos.copy()
    this.target = pos.copy()
    this.rad = strokeRad
    this.vel = createVector(0, 0)
    this.desiredVel = createVector(0, 0)
    this.steering = 0.1
    this.speedLimit = 50
    this.easingValue = -0.55 // between -1 and -0.46
  }
  
  static process(groups, xOff, yOff, b){    
    let slowThreshold = 5;
    
    for (let ps of groups){
      for (let p = 0; p < ps.length; p++){
        let c = ps[p]

        c.desiredVel = p5.Vector.limit(p5.Vector.sub(c.target, c.pos), c.speedLimit)
        c.vel.limit(c.speedLimit)
        let left = p5.Vector.mult(c.vel, 1-c.steering)
        let right = p5.Vector.mult(c.desiredVel, c.steering)
        let steer = p5.Vector.add(left, right)
        c.vel = p5.Vector.limit(p5.Vector.add(c.vel, steer), c.speedlimit)

        // slow the bitch down
        let distB = p5.Vector.mag(p5.Vector.sub(c.target, c.pos))
        c.vel.add(p5.Vector.mult(c.vel, c.easingValue))

        c.pos.add(c.vel)
        
        
        // handle collision
        let vBet = p5.Vector.sub(c.pos, p5.Vector.sub(b.pos, createVector(width/2+xOff, height/2+yOff)))
        let m = p5.Vector.mag(vBet)
        if (m < b.rad + strokeRad/2){  // In collision
          c.pos.add(p5.Vector.sub(p5.Vector.setMag(vBet, b.rad + strokeRad/2), vBet))
          c.vel = p5.Vector.mult(b.vel, 1.2)
          let velVariance = p5.Vector.fromAngle(random(TAU), 10)
          c.vel.add(velVariance)
        }
        
        
        // display Line when stationary and point when moving
        strokeWeight(strokeRad)
        
        let threshold = 4;
        let d = 0;  // distance of next point in line
        if (p < ps.length-1){
          d = p5.Vector.dist(ps[p+1].target, ps[p+1].pos)
        }
        if (d <= threshold && distB <= threshold){
          if (p < ps.length-1){
          // Line
            line(c.pos.x+xOff, c.pos.y+yOff, ps[p+1].pos.x+xOff, ps[p+1].pos.y+yOff)
          }
          else{
            line(ps[p].pos.x+xOff, ps[p].pos.y+yOff, ps[0].pos.x+xOff, ps[0].pos.y+yOff)
          }
        }else{
          // Point
          point(c.pos.x + xOff, c.pos.y + yOff)
        }
      }
    }
  }
}

let clockRadius = 0;
let hourRadius = 0;
let minuteRadius = 0;
let secondRadius = 0;
let strokeRad = 5;

let font;
let clockFontSize = 125;
let clock3Groups;
let clock6Groups;
let clock9Groups;
let clock12Groups;
let clockN = 60

let globalPoints = []

let wreckingBall;

function preload() {
  font = loadFont("Roboto-Regular.ttf");
}

function setup() { 
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB)
  rectMode(CENTER);
  
  clockRadius = width/2 - strokeRad
  secondRadius = clockRadius - strokeRad
  hourRadius = clockRadius * 0.6
  minuteRadius = clockRadius * 0.9
  
  wreckingBall = new ball()
  
  clock3Groups = generateDotPath(clock3Raw, clockN);
  clock6Groups = generateDotPath(clock6Raw, clockN);
  clock9Groups = generateDotPath(clock9Raw, clockN);
  clock12Groups = generateDotPath(clock12Raw, clockN);
  
  let g = [310, 20, 0, 300, -315, 20, -80, -265].map(function(n){
    return (n/900) * width
  })
  
  globalPoints = [
    {groups: clock3Groups, xOff: g[0], yOff: g[1]},
    {groups: clock6Groups, xOff: g[2], yOff: g[3]},
    {groups: clock9Groups, xOff: g[4], yOff: g[5]},
    {groups: clock12Groups, xOff: g[6], yOff: g[7]},
  ]
  
  // vectorToPoints(font.textToPoints('9', ps[2], ps[3], clockFontSize, { sampleFactor:  0.15 }))
  // noLoop()
} 

function vectorToPoints(ps){
  let s = ""
    for (let p of ps){
      let temp = `${p.x.toFixed(2)}, ${p.y.toFixed()}, `
      s = s.concat(temp)
      // formatted.push(p.x - width/2)
      // formatted.push(p.y - width/2)
    }
    console.log(s)
}

function draw() { 
  background(90);
  translate(width/2, height/2)
  
  let hourAngle = (hour() / 12) * TAU - PI/2
  let minuteAngle = (minute() / 60) * TAU - PI/2
  let secondAngle = (second() / 60) * TAU - PI/2
  strokeWeight(5)
  stroke(0, 70, 100)
  line(0, 0, secondRadius * cos(secondAngle), secondRadius * sin(secondAngle))
  strokeWeight(10)
  stroke(0, 70, 100)
  line(0, 0, minuteRadius * cos(minuteAngle), minuteRadius * sin(minuteAngle))
  stroke(0, 70, 100)
  line(0, 0, hourRadius * cos(hourAngle), hourRadius * sin(hourAngle))
  
  stroke(220, 70, 70)
  noFill()
  strokeWeight(strokeRad)
  circle(0, 0, clockRadius * 2) 
  
  if (mouseIsPressed){
    wreckingBall.process()
  }else{
    wreckingBall.pos = createVector(-windowWidth, -windowHeight)
  }
  for (let g of globalPoints){
    smartPoint.process(g.groups, g.xOff, g.yOff, wreckingBall)
  }
  
  
  // strokeWeight(2)
  // stroke(0)
  // line(-width/2, 0, width/2, 0)
  // line(0, -height/2, 0, height/2)
}

function touchStarted(){
  return false;
}

function touchMoved(){
  return false;
}

function touchEnded(){
  return false;
}

function drawShape(x, y, ps){
  push()
  translate(x, y)
  beginShape()
  for (let i = 0; i < ps.length; i++){
    vertex(ps[i].pos.x, ps[i].pos.y)
  }
  endShape()
  pop()
}

function drawDotGroups(x, y, ps, type="POINTS", isSmart=true){
  push()
  translate(x, y)
  if (type == "POINTS"){
    for (let group of ps){
      for (let p of group){
        let c = (isSmart) ? p.pos : p
        point(c.x, c.y)
      }
    }
  }
  else if (type == "LINES"){
    for (let group of ps){
      for (let p = 0; p < group.length-1; p++){
        line(group[p].pos.x, group[p].pos.y, group[p+1].pos.x, group[p+1].pos.y)
      }
    }
  }
  pop()
}

// da best
function generateDotPath(rawShapes, n){
  let vecShape = []
  let spacing = 0;
  let final = []
  let groups = []
  
  for (let rawShape of rawShapes){
    // convert raw points into createVector's
    for (let i = 0; i < rawShape.length; i+=2){
      vecShape.push(createVector(rawShape[i], rawShape[i+1]))
    }
    
    // calculate spacing between points
    let totalLength = 0;
    for (let i = 0; i < vecShape.length-1; i++){
      totalLength += p5.Vector.mag(p5.Vector.sub(vecShape[i+1], vecShape[i]))
    }
    spacing = totalLength / n;

    let percentage = 0
    let currLength = 0;

    for (let i = 0; i < 1; i+=spacing/totalLength){
      percentage = i
      currLength = 0

      for (let i = 0; i < vecShape.length - 1; i++){
        let vBet = p5.Vector.sub(vecShape[i+1], vecShape[i])
        let m = p5.Vector.mag(vBet)
        currLength += m

        if (currLength / totalLength >= percentage){
          let prevLength = currLength - m
          let distance = (percentage * totalLength - prevLength) / (currLength - prevLength)

          let scaled = p5.Vector.setMag(vBet, distance * m)
          let finalPos = p5.Vector.add(vecShape[i], scaled)
          final.push(new smartPoint(finalPos))
          break;
        }

      }
    }
    vecShape = []
    groups.push(final)
    final = []
  }
  
  return groups
}
